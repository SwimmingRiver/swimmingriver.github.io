<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>수영의 TIL</title>
</head>
<body>
<h1>React</h1>
<p>
  npm i react-hook-form 
  useform 선언하기
const {register,watch,handleSubmit...}=useForm();
.
.
.
validation
<form...>
<input ...{}//useForm범위 onSubmit={handleSubmit(onValid)}//Html범위>
html범위에 유효성검사를 해도 되지만, 사용자의 브라우저나 버전 등등에 
지원이 안되는 경우를 대비해  useForm의 범위에서 사용
  
  </p>
  <hr/>
  <h1>react hook form을 이용해서 사용자의 정보를 받는 form 만들기</h1>
  <p>interface IForm{
    name:string;
    email:string;
    userName:string;
    password:string;
    passwordConfirm:string;
    extraError?:string;

}

function ToDoList(){
    const {register,handleSubmit,formState:{errors},setError,
}=useForm<IForm>(
    {
        defaultValues:{
            email:"@naver.com",
        }
    }
    );
    const onValid = (data:any)=>{
        if(data.password !== data.passwordConfirm){
            setError("passwordConfirm",{message:"password are not the same."},{shouldFocus:true});
        }
        // setError("extraError",{message:"Server offline."});
    }
    console.log(errors);
    return(
       <div>
    <form style={{display:"flex",flexDirection:"column"}} onSubmit={handleSubmit(onValid)}>
    
    <input {...register("name",{
                    required:"write here",
                    validate: {
                        noRiver:(value)=>
                        value.includes("river") ? "no river allowed" : true,
                        noRiva:(value)=>
                        value.includes("riva") ? "no riva allowed" : true,
                    },
                    })} placeholder="Name"/>
                      <span>
        {errors?.name?.message}
    </span>

    <input {...register("email",{
        required:"Email is required",
        pattern:{
            value:/^[A-Za-z0-9._%+-]+@naver.com$/,
            message:"Only naver.com allowed",
        }
    })} placeholder="Email"/>
    <span>
        {errors?.email?.message}
    </span>
    <input {...register("userName",{required:true,minLength:10})} placeholder="userName"/>
    <span>
        {errors?.userName?.message}
    </span>
    <input {...register("password",{required:'password is required',minLength:{
        value:5,
        message:"It's too short.",
    }})} placeholder="password"/>
      <span>
        {errors?.password?.message}
    </span>
    <input {...register("passwordConfirm",{required:true,minLength:10})} placeholder="passwordConfirm"/>
    <span>
        {errors?.passwordConfirm?.message}
    </span>
        {/* <input {...register("toDo")} placeholder="Write a to do"/> */}
        <button>Add</button>
        <span>{errors?.extraError?.message}</span>
    </form>
    </div>
    )
}</p>
    <hr/>
<p>  <h1>React-router-dom</h1>

<h2>React-router 시작하기</h2>

Npm i react-router-dom
<br/>
App.js
Import {HashRouter,Route}from “react-router-dom”;
<br/>
Function App(){
	return
 <HashRouter>
	<Route path=“home/” component={Home}/>
	<Route path=“/about” component={About}/><br/>
	//path와 component는 이름이 같을 필요는 없다.<br/>
</HashRouter>
}

//case1:<br/>
Function App(){
	return
 <HashRouter>
	<Route path=“home/”>
		<h1>Home</h1>
	</Route>
	<Route path=“home/intro”><h1>HomeIntro</h1></Route><br/>
	//home/intro 접속시 home과 homeintro 두 개 다 렌더링됨<br/>
	<Route path=“/about”><h1>About</h1><Route/><br/>
</HashRouter>
}<br/>
Solution of the case 1:<br/>
<Route path =“/” exact={true} component={Home}><br/>
//정확하게 path가 일치하는 것만 렌더<br/>
*버전업후에 HashRouter -> BrowserRouter, component->element
Route를 Routes로 감싸줘야함<br/>

페이지 이동을 위한 Navigation<br/>

Navigation.js<br/>

Import {Link} from “react-router-dom”;<br/>
Function Navigation(){<br/>
	Return(<br/>
		<div><br/>
			<Link to=“/“>Home</Link><br/>
			<Link to=“/about”>About</Link><br/>
		</div>	<br/>
	)
}
<br/>
App.js<br/>
…
Import Navigation from “~~~”;<br/>

Function App(){
	return
 <HashRouter><br/>
<Navigation/> // Link는 반드시 Routes안에 있어야 작동됨<br/>
	<Route path=“home/”><br/>
		<h1>Home</h1>
	</Route>
	<Route path=“home/intro”><h1>HomeIntro</h1></Route><br/>
	<Route path=“/about”><h1>About</h1><Route/><br/>
</HashRouter><br/>
}

	 <h2>Routes 간에 props공유</h2>

Function App(){
	return
 <HashRouter>
	<Route path=“home/”>
		<h1>Home</h1>
	</Route>
	<Route path=“home/intro”><h1>HomeIntro</h1></Route>
	<Route path={<br/>
				{<br/>
					pathname:”/about”,<br/>
					state:{fromNavigation:true<br/>
						}<br/>
				}<br/>
		}><h1>About</h1><Route/>
</HashRouter>
}
   </p>
   <hr/>
	<h1>Recoil</h1>
	<p>Recoil이 없이 개발을 하게 되면 component간에 state,props등을 가져오기가 굉장히 복잡해진다<br/>
		(큰 규모의 개발을 안해봐서 지금까지 느낀바로는 필요성은 이거밖에 모르겠다)</p><br/>
	<p>atom은 recoil 정의한다<br/>
		ex) const isDarkAtom = atom({
			key: 'isDarkState',
			default:[],
		})
	</p>
		
	<p>atom 값을 얻으려 할 때는 useRecoilValue<br/>
		ex)const isDark = useRecoilValue(isDarkAtom);<br/>
		<br/>
		useSetRecoil은 매개변수로 atom을 받고,atom을 변경하는 함수로 <br/>
		ex) const setDarkAtom = useSetRecoilState(isDarkAtom);<br/>
		<br/>
		
	<p>react hooks의 useState처럼 사용할수도 있다.<br/>
		const [isDarkAtom,setValue]=useRecoilState(isDarkState);<br/>
		//이렇게하면 값을 얻고,변환을 한번에 할 수도 있다.<br/>
	</p>
	<h3>예시는 웹 테마를 바꾸기를 위한props </h3>
		 <h1>Recoil2</h1>
	 <p>
	 selector<br/>
selector는 atom을 가져가서 output을 변형할 수 있다<br/>

import {atom,selector} from "recoil";<br/>

export const minuteState = atom({<br/>
	key:"min",<br/>
	default:0,<br/>
})<br/>

export const hourSelector =selector({<br/>
	key:"hours",<br/>
	get:({get})=>{<br/>
	 return 111111; //get에서 get을 인자로 함수를 쓰면. selector값은 항상 return값	<br/>
	}<br/>
})<br/>

//분을 시로 변환해주는 selector<br/>
export const hourSelector =selector<number>({ // <number>형만 리턴<br/>
	key:"hours",<br/>
	get:({get})=>{<br/>
	const mins = get(minuteState);<br/>
	return mins / 60; <br/>
	}
})<br/>

	
	</p>
	 <h1>enum</h1>
	 <p>
	 enum<br/>

enum categories{<br/>
	"TO_DO",<br/>
	"DOING",<br/>
	"DONE,	<br/>
}<br/>
enum을 쓰면 enum 안에 있는 값을 불러 올 수 있다. 단순 타이핑으로 했을때 
오타등으로 생기는 문제를 줄일수도있다.

enum이름.enum안에 있는 요소 이런 형태로 불러 올수 있다<br/>
enum은 따로 설정하지않으면 값은 숫자값으로 저장된다.
<br/>
enum categories{<br/>
	"TO_DO":"TO_DO",<br/>
	"DOING":"DOING",<br/>
	"DONE":"DONE",	<br/>
}
이런식으로 값을 정해주면 정해진 값으로 저장된다<br/>
		 
		 
	 </p>
	

	 </p><br/>
</body>

</html>
