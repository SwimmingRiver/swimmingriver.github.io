<!DOCTYPE html>
<html>
  <head>
  <meta charset="UTF-8">
    <title>수영의 TIL Etc</title>
    
   
  </head>
  <body>
    <h1>수영의 TIL Etc</h1>
    
    
     <h2>라이브러리와 프레임워크</h2>
    <hr/>
    <p>
      라이브러리: 개발자가 필요한 도구들을 모아놓은 집합,개발자가 필요할 때 도구들을 호출하는 형태로 사용 <br/>
      프레임워크: sw의 보완을 위해 상호협력하는 클래스,인터페이스의 집합<br/>
      차이점:둘의 차이점에는 *제어흐름에 대해 큰 차이가 있다. <br/>
      *제어흐름:(영어: control flow 또는 flow of control)은 프로그램에서 실행되는 각 구문, 명령어나 함수가 호출되는 순서를 의미한다.<br/>
      한편 제어흐름(制御흐름)을 알고리즘에 따른 명령문을 처리할 때 관련 장치들이 연속적으로 작동되는 과정으로 정의해본다면 제어문은 주어진 조건의 결괏값에 따라서 프로그램의 수행 순서를 제어하거나 문장들의 수행 횟수를 조정하는 문장을 가리킨다.
      프레임워크가 흐름을 스스로 제어하고 개발자가 코드를 입력하는 형태라면, 라이브러리는 개발자가 흐름을 통제하며 필요한 라이브러리를 가져오는 형태로 볼 수있다.<br/>
      예)프레임 워크:Spring,Django.../라이브러리:jQuery,GUI...<br/>
      *어떤 사람은 자동차에 비유하여 설명했다. 라이브러리는 자동차의 바퀴,헤드라이트,에어백이고,프레임워크는 자동차 프레임 자체라고 설명한다.<br/>
      *React는 프레임워크가 아니라 라이브러리라고 한다. 다른 프레임워크들이 기본으로 가진것을 react는 다른 라이브러리의 호출없이 사용할 수 없는 기능이 많아 라이브러리로 분류된다고한다,.<br/>
    </p>
    <hr/>
    <h2>Java 기초 복습</h2>
    <p>
      
    println(문자,숫자,변수);<br/>

int,long+L,short,byte 크기는 long,int,short,byte순<br/>

형변환(type casting) : long l = 30L; int i = (int)30L; //반대 경우는 자동 형변환(int->long)<br/>
 
double.float+f<br/>

boolean true.false<br/>

char c = '';<br/>

string str = "";
<br/>
Math class
Math.max(10,30) 최대값
abs 절대값 ...
<br/>
Integer.parseInt("");
String.valueOf(0);
<br/>
Random random = new Random();
int rand = random.nextInt(0,4);
<br/>
Scanner sc = new Scanner(Systm.in);
<br/>
if,else,else if
? 삼항연산자
<br/>
배열
int[] score;
int[] score = new int[5];
.length 배열길이
 <br/>
List
<br/>
ArrayList<Integer> arrList = new ArrayList<>();//정수형 arrayList 선언
<br/>
arrList.add(0,10); //list에 index 0 에 정수 10 추가
<br/>
arrList.size()//arrlist 크기
<br/>
arrList.get(0)//Index 0 의 값
<br/>
"..." 0보다 큰 n번을 배열 형태로 불러옴 <br/>
	    
 public static int add(int...nubers){
	int sum = 0;
	for(int i=0;i<numbers.length;i++){
		sum += i;
	}<br/>
	return sum;
}//add();에서 파라미터 갯수를 원하는 만큼 쓸 수 있다.<br/>
	    
	    Public class Main{<br/>
	Public static void main(String[] args){<br/>
		….<br/>
	Person person = new Person();<br/>
	Person person2 = 
	new Person(“John”,20);
	}<br/>
}<br/>
class Person{<br/>
	public String name;<br/>
	private int age;//접근자 제한
<br/>
	person(){//기본 생성자
<br/>
	}<br/>
	person(String name,int age){<br/>
		this.name = name; //받은 값과 이름이 값은 변수의 구분<br/>
		this.age=age;<br/>
	}<br/>
} <br/>
class Student extends Person{<br/>
//Person class 상속<br/>
}
	 
    </p>
	    <hr/>
	       <h2>비동기</h2>
	  <p>
javascript는 synchoronous 코드의 순서대로 작동함<br/>
Hoisting: var, function 선언들이 자동적으로 작동순서의 상위로 정해짐<br/>
asynchoronus는 비동기적으로 언제 코드 작동할지 모름?<br/>
ex) setTimeout(func(){},1000);//1초뒤에 function 출력<br/>

Callback도 sync/async로 나눠짐<br/>

Promise<br/>

Js에서 비동기 제어를 위한 object<br/>
중점:상태,제공자와 사용자의 차이점 이해<br/>
상태: 수행중(pending)->완료(fulfilled),실패(rejected)
제공자(producer)와 사용자(consumer)<br/>

Producer 관점: 새로운 promise를 만들 때부터 함수가 작동한다.<br/>
예를 들면, promise안에 서버와 통신함수를 넣었다면 그 순간부터 서버와 통신을 하기위한 작업을 한다.<br/>

Consumer 관점:then,catch,finally<br/>
Ex) promise<br/>
	.then((value)=>console.log(value))//promise가 정상작동하여 넘겨준 값을 출력	<br/>	
.catch(error=>{
							console.log(error);
							})//실패시 에러 출력<br/>
						.finally(()=>{<br/>
								console.log(“finally”);<br/>
							})//	작동의 성공과 실패 여부와 
								상관없이 최종 출력 되는 값<br/>

Promise Chaining<br/>


Async/await<br/>
promise를 좀 더 간단하게 쓸 수 있게 한 형식(?)<br/>
//경우에 따라 async와 promise 둘 중 하나가  더 적합함<br/>
함수명 앞에 async를 붙이면 promise로 사용할 수 있음<br/>

Await <br/>
await 2개가 함께있을때 2개가 동기적으로 작동된다 <br/>
출력까지 2초가 걸리는 함수가 2개가 있으면 결과가 나오는데 4초가 걸린다<br/>
=>
Promise.all([])을 사용한테 괄호안에 배열형태로 promise들을 전달하면 <br/>
promise들을 병렬적으로 호출한다.<br/>

Promise.race([])는 .all과 같이 배열로 promise들을 받고 그 중에서 가장 빨리 처리되는 하나만
호출한다
<br/>
 

	  </p>
  </body>
</html>
